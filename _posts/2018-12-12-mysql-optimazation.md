---
layout: post
title: MySQL 大表优化方案
description: 常见的一些优化方法
category: blog
---

## 单表优化
除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：

## 字段
<ul>
    <li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li>
    <li>VARCHAR的长度只分配真正需要的空间</li>
    <li>使用枚举或整数代替字符串类型</li>
    <li>尽量使用TIMESTAMP而非DATETIME</li>
    <li>单表不要有太多字段，建议在20以内</li>
    <li>避免使用NULL字段，很难查询优化且占用额外索引空间</li>
    <li>用整型来存IP</li>
</ul>

## 索引
<ul>
    <li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li>
    <li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
    <li>值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段</li>
    <li>字符字段只建前缀索引</li>
    <li>字符字段最好不要做主键</li>
    <li>不用外键，由程序保证约束</li>
    <li>尽量不用UNIQUE，由程序保证约束</li>
    <li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li>
</ul>

## 查询SQL

* 可通过开启慢查询日志来找出较慢的SQL
* 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边
* sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
* 不用SELECT *
* OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
* 不用函数和触发器，在应用程序实现
* 避免%xxx式查询
* 少用JOIN
* 使用同类型进行比较，比如用'123'和'123'比，123和123比
* 尽量避免在WHERE子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描
* 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
* 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大


## 引擎
目前广泛使用的是MyISAM和InnoDB两种引擎：

### MyISAM
MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
<ul>
	<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
    <li>不支持事务</li>
    <li>不支持外键</li>
    <li>不支持崩溃后的安全恢复</li>
    <li>在表有读取查询的同时，支持往表中插入新纪录</li>
    <li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
    <li>支持延迟更新索引，极大提升写入性能</li>
    <li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li>
</ul>

### InnoDB
InnoDB在MySQL 5.5后成为默认索引，它的特点是：

<ul>
<li>支持行锁，采用MVCC来支持高并发</li>
<li>支持事务</li>
<li>支持外键</li>
<li>支持崩溃后的安全恢复</li>
<li>不支持全文索引</li>
</ul>


总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表.


## 升级硬件
Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能

## 读写分离
也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离.

## 缓存
缓存可以发生在这些层次：

* MySQL内部：在系统调优参数介绍了相关设置

* 数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object

* 应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object

* Web层：针对web页面做缓存

* 浏览器客户端：用户端的缓存

可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：

* 直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。

* 回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。

## 表分区

MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码

对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引

用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：

### 分区的好处：

* 可以让单表存储更多的数据

* 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作

* 部分查询能够从查询条件确定只落在少数分区上，速度会很快

* 分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备

* 可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争

* 可以备份和恢复单个分区

### 分区的限制和缺点：

* 一个表最多只能有1024个分区

* 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来

* 分区表无法使用外键约束

* NULL值会使分区过滤无效

* 所有分区必须使用相同的存储引擎

### 分区的类型：

* RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区

* LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择

* HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式

* KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值

### 分区适合的场景：

* 最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：

CREATE TABLE members (
    firstname VARCHAR(25) NOT NULL,
    lastname VARCHAR(25) NOT NULL,
    username VARCHAR(16) NOT NULL,
    email VARCHAR(35),
    joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);

查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。

如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存

另外MySQL有一种早期的简单的分区实现 – 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代


#### 垂直拆分

垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。

##### 垂直拆分的优点是：

* 可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)

* 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起

* 数据维护简单

##### 缺点是：

* 主键出现冗余，需要管理冗余列

* 会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力

* 依然存在单表数据量过大的问题（需要水平拆分）
事务处理复杂

#### 水平拆分

水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表

库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决

前面垂直拆分的用户表如果进行水平拆分

实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表

##### 水平拆分的优点是：
* 不存在单库大数据和高并发的性能瓶颈
* 应用端改造较少
* 提高了系统的稳定性和负载能力

##### 缺点是：
* 分片事务一致性难以解决
* 跨节点Join性能差，逻辑复杂
* 数据多次扩展难度跟维护量极大
